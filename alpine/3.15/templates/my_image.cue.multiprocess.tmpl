package my_image

import (
    "dagger.io/dagger"
    "dagger.io/dagger/core"
    "universe.dagger.io/docker"
    "universe.dagger.io/docker/cli"
)

// This action builds a docker image from ${CONTAINER_IMAGE_NAME}:${CONTAINER_IMAGE_TAG}.
// Build steps are defined in native CUE.
#Build: {

    // Image name
    name?: string

    // Image tag
    tag?: string

    // Environement directory
    environment: dagger.#FS
 
    // Service directory
    services: dagger.#FS

    // Container image
    image: _build.output

    // Build steps
    _build: docker.#Build & {
        steps: [
            docker.#Pull & {
                source: "${CONTAINER_IMAGE_NAME}:${CONTAINER_IMAGE_TAG}"
            },
            docker.#Set & {
                config: core.#ImageConfig & {
                    env: {
                        CONTAINER_IMAGE_NAME?: name
                        CONTAINER_IMAGE_TAG?: tag
                    }
                }
            },
            docker.#Run & {
                entrypoint: ["/bin/bash", "-c", "apt -y update && /container/tools/add-multiple-process-stack && install-and-clean && [....]"]
            },
            docker.#Copy & {
                contents: services
                dest:     "/container/services"
            },
            docker.#Run & {
                entrypoint: ["/container/tools/install-services"]
            },
            docker.#Copy & {
                contents: environment
                dest:     "/container/environment/${ENVIRONMENT_DIRECTORY}"
            },
        ]
    }
}

// Example usage in a plan
dagger.#Plan & {
    client: {
        filesystem: {
            "./environment": read: contents: dagger.#FS
            "./services": read: contents: dagger.#FS
        }
        network: "unix:///var/run/docker.sock": connect: dagger.#Socket
        env: {
            IMAGE_NAME: string | *"example/my-image"
            IMAGE_TAG: string | *"develop"
        }
    }

    _imageId: client.env.IMAGE_NAME + ":" + client.env.IMAGE_TAG

    actions: {
        build: #Build & {
            name: client.env.IMAGE_NAME
            tag: client.env.IMAGE_TAG

            environment: client.filesystem."./environment".read.contents
            services: client.filesystem."./services".read.contents
        }
        load: cli.#Load & {
            "image": build.image
            "host":  client.network."unix:///var/run/docker.sock".connect
            "tag":   _imageId
        }
        push: docker.#Push & {
            image: build.image
            dest:  _imageId
        }
    }
}
