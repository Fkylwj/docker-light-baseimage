#!/usr/bin/python3 -u
# -*- coding: utf-8 -*-

from multiprocessing.connection import wait
import os
import os.path
import subprocess
import sys
import stat
import signal
import errno
import argparse
import time
import shlex
import json
import shutil
import tempfile
from datetime import datetime
from dotenv import load_dotenv

KILL_PROCESS_TIMEOUT = int(os.environ.get(
    'CONTAINER_KILL_PROCESS_TIMEOUT', 30))

KILL_ALL_PROCESSES_TIMEOUT = int(os.environ.get(
    'CONTAINER_KILL_ALL_PROCESSES_TIMEOUT', 30))

terminated_child_processes = {}

LOG_LEVEL_NONE = 0
LOG_LEVEL_ERROR = 1
LOG_LEVEL_WARNING = 2
LOG_LEVEL_INFO = 3
LOG_LEVEL_DEBUG = 4
LOG_LEVEL_TRACE = 5

log_level_switcher = {"none": LOG_LEVEL_NONE, "error": LOG_LEVEL_ERROR, "warning": LOG_LEVEL_WARNING,
                      "info": LOG_LEVEL_INFO, "debug": LOG_LEVEL_DEBUG, "trace": LOG_LEVEL_TRACE}

log_level_switcher_inv = {v: k for k, v in log_level_switcher.items()}

# Keep sync with log-helper default values
log_level = LOG_LEVEL_INFO
log_json = False

ENVIRONMENT_FILES_IMPORT_DIR = "/container/environment"
ENVIRONMENT_FILES_PREFIX = ('.env')

TEMPLATES_DIR = "/container/templates"

# Keep sync with values in install-services file.
RUN_DIR = "/container/run"
RUN_STARTUP_DIR = RUN_DIR + "/startup"
RUN_PROCESS_DIR = RUN_DIR + "/process"
RUN_FINISH_DIR = RUN_DIR + "/finish"

RUN_VAR_DIR = "/container/run/var"
RUN_VAR_STATE_DIR = RUN_VAR_DIR + "/state"
RUN_VAR_GENERATE_DIR = RUN_VAR_DIR + "/generate"

ENVIRONMENT_LOG_LEVEL_KEY = 'CONTAINER_LOG_LEVEL'
ENVIRONMENT_LOG_FORMAT_KEY = 'CONTAINER_LOG_FORMAT'
ENVIRONMENT_VAR_DIR_KEY = 'CONTAINER_VAR_DIR'
ENVIRONMENT_STATE_DIR_KEY = 'CONTAINER_STATE_DIR'

ENVIRONMENT_IMAGE_NAME_KEY = 'CONTAINER_IMAGE_NAME'
ENVIRONMENT_IMAGE_TAG_KEY = 'CONTAINER_IMAGE_TAG'


class AlarmException(Exception):
    pass


def write_log(level, message):
    now = datetime.now().isoformat()

    if log_json:
        dictionary = {"datetime": now,
                      "level": level.strip(), "message": message}
        sys.stderr.write(json.dumps(dictionary) + "\n")
        return

    for line in message.splitlines():
        sys.stderr.write("*** %s | %s | %s\n" % (now, level, line))


def error(message):
    if log_level >= LOG_LEVEL_ERROR:
        write_log(" ERROR ", message)


def warning(message):
    if log_level >= LOG_LEVEL_WARNING:
        write_log("WARNING", message)


def info(message):
    if log_level >= LOG_LEVEL_INFO:
        write_log(" INFO  ", message)


def debug(message):
    if log_level >= LOG_LEVEL_DEBUG:
        write_log(" DEBUG ", message)


def trace(message):
    if log_level >= LOG_LEVEL_TRACE:
        write_log(" TRACE ", message)


def debug_env():
    message = "Environment variables:\n"
    for name, value in list(os.environ.items()):
        message += name + "=" + value + "\n"
    debug(message)


def ignore_signals_and_raise_keyboard_interrupt(signame):
    signal.signal(signal.SIGTERM, signal.SIG_IGN)
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    raise KeyboardInterrupt(signame)


def raise_alarm_exception():
    raise AlarmException('Alarm')


def listdir(path):
    try:
        result = os.stat(path)
    except OSError:
        return []
    if stat.S_ISDIR(result.st_mode):
        return sorted(os.listdir(path))
    else:
        return []


def is_exe(path):
    try:
        return os.path.isfile(path) and os.access(path, os.X_OK)
    except OSError:
        return False


def xstr(s):
    if s is None:
        return ''
    return str(s)


def generator(args):
    if not args.generate and not args.generate_multiprocess and not args.generate_service and not args.generate_service_available:
        return

    if args.generate and args.generate_multiprocess:
        error("--generate option can't be used with --generate-multiprocess set at the same time.")
        sys.exit(1)

    if (args.generate or args.generate_multiprocess) and (args.generate_service or args.generate_service_available):
        error("--generate-service and --generate-service-available options can't be used with --generate or --generate-multiprocess set at the same time.")
        sys.exit(1)

    generator_print_files = False

    if not os.path.isdir(RUN_VAR_GENERATE_DIR):
        generator_print_files = True

        warning("Generator directory not found: %s. Generated files will be printed to the console." %
                RUN_VAR_GENERATE_DIR)
        warning("To get generated files directly on your file system mount a host directory to %s." %
                RUN_VAR_GENERATE_DIR)
        warning("docker run --rm --volume $(pwd)/example:%s %s %s" % (RUN_VAR_GENERATE_DIR,
                get_container_image(), get_generator_command_line_options(args)))

        try:
            os.mkdir(RUN_VAR_GENERATE_DIR)
        except OSError as e:
            error("Error creating %s directory" % RUN_VAR_GENERATE_DIR)
            sys.exit(1)

    if args.generate:
        generate(args.generate)

    elif args.generate_multiprocess:
        generate_multiprocess(args.generate_multiprocess)

    if args.generate_service:
        for service in args.generate_service:
            generate_service(service)

    if args.generate_service_available:
        for service_available in args.generate_service_available:
            generate_service_available(service_available)

    if generator_print_files:
        separator = "--------------------------------------------------------------------------------"

        for subdir, _, files in os.walk(RUN_VAR_GENERATE_DIR):
            for file in files:
                file_path = os.path.join(subdir, file)

                print(separator)
                print(file_path.replace(RUN_VAR_GENERATE_DIR, ""))
                print(separator)

                with open(file_path, "r") as f:
                    print(f.read())

    sys.exit(0)


def get_generator_command_line_options(args):
    options = ""

    if(args.generate):
        options += "--generate %s " % args.generate

    if(args.generate_multiprocess):
        options += "--generate-multiprocess %s " % args.generate_multiprocess

    if args.generate_service:
        for service in args.generate_service:
            options += "--generate-service %s " % service

    if args.generate_service_available:
        for service_available in args.generate_service_available:
            options += "--generate-service-available %s " % service_available

    return options


def generate_envsubst_templates(source, dest=None, environ=None):
    # change log level to warning for envsubst-templates
    subprocess_environ = os.environ.copy()
    subprocess_environ[ENVIRONMENT_LOG_LEVEL_KEY] = xstr(LOG_LEVEL_WARNING)

    if not os.path.isdir(os.path.join(ENVIRONMENT_FILES_IMPORT_DIR, '00-default')):
        subprocess_environ["ENVIRONMENT_DIRECTORY"] = "00-default"
    else:
        subprocess_environ["ENVIRONMENT_DIRECTORY"] = "xx-some-dir"

    if environ:
        subprocess_environ = subprocess_environ | environ

    if dest:
        dest = os.path.join(RUN_VAR_GENERATE_DIR, dest)
    else:
        dest = RUN_VAR_GENERATE_DIR

    subprocess.run("envsubst-templates %s %s" %
                   (source, dest), shell=True, env=subprocess_environ)


# generate single process image files
def generate(option, service_name="my-service"):
    debug("Generate single process templates")
    with tempfile.TemporaryDirectory() as tmpdir:
        trace("Use temporary directory: %s" % tmpdir)

        if option == "dockerfile":
            shutil.copy(os.path.join(TEMPLATES_DIR, "Dockerfile.tmpl"), tmpdir)
        else:
            shutil.copy(os.path.join(TEMPLATES_DIR,
                        "my_image.cue.tmpl"), tmpdir)

        shutil.copytree(os.path.join(TEMPLATES_DIR, "environment"),
                        os.path.join(RUN_VAR_GENERATE_DIR, "environment"))

        generate_envsubst_templates(tmpdir)

    generate_service(service_name, "services")


def generate_multiprocess(option):

    generate(option, "service-1")
    generate_service("service-2", "services")

    debug("Generate multiprocess templates")
    with tempfile.TemporaryDirectory() as tmpdir:
        trace("Use temporary directory: %s" % tmpdir)

        if option == "dockerfile":
            shutil.copy(os.path.join(TEMPLATES_DIR, "Dockerfile.multiprocess.tmpl"), os.path.join(
                tmpdir, "Dockerfile.tmpl"))
        else:
            shutil.copy(os.path.join(TEMPLATES_DIR, "my_image.cue.multiprocess.tmpl"), os.path.join(
                tmpdir, "my_image.cue.tmpl"))

        generate_envsubst_templates(tmpdir)


def generate_service(name, in_dir=None):
    debug("Generate service templates: %s" % name)
    with tempfile.TemporaryDirectory() as tmpdir:
        trace("Use temporary directory: %s" % tmpdir)

        shutil.copytree(os.path.join(TEMPLATES_DIR, "service"),
                        os.path.join(tmpdir, name))

        generate_envsubst_templates(tmpdir, in_dir, {"SERVICE_NAME": name})


def generate_service_available(name, in_dir=None):

    generate_service(name, in_dir)

    debug("Generate service-available templates: %s" % name)
    with tempfile.TemporaryDirectory() as tmpdir:
        trace("Use temporary directory: %s" % tmpdir)

        shutil.copytree(os.path.join(
            TEMPLATES_DIR, "service-available"), os.path.join(tmpdir, name))

        generate_envsubst_templates(tmpdir, in_dir, {"SERVICE_NAME": name})


def import_env_files():
    if not os.path.exists(ENVIRONMENT_FILES_IMPORT_DIR):
        warning(ENVIRONMENT_FILES_IMPORT_DIR + " don't exists")
        return

    env_backup = dict(os.environ)

    for subdir, _, files in os.walk(ENVIRONMENT_FILES_IMPORT_DIR):
        for file in sorted(files):
            if file.startswith(ENVIRONMENT_FILES_PREFIX):

                filepath = os.path.join(subdir, file)

                info('Load environment file ' + filepath)
                load_dotenv(filepath, override=True)
                set_env(env_backup)


def set_env(env):
    for k, v in env.items():
        if v is not None:
            os.environ[k] = v


def set_dir_env():
    os.environ[ENVIRONMENT_VAR_DIR_KEY] = RUN_VAR_DIR
    trace(ENVIRONMENT_VAR_DIR_KEY + "=" + os.environ[ENVIRONMENT_VAR_DIR_KEY])

    os.environ[ENVIRONMENT_STATE_DIR_KEY] = RUN_VAR_STATE_DIR
    trace(ENVIRONMENT_STATE_DIR_KEY + "=" +
          os.environ[ENVIRONMENT_STATE_DIR_KEY])


def set_log_env():
    os.environ[ENVIRONMENT_LOG_LEVEL_KEY] = xstr(log_level)
    info(ENVIRONMENT_LOG_LEVEL_KEY + "=" + os.environ[ENVIRONMENT_LOG_LEVEL_KEY] + " (" + log_level_switcher_inv.get(int(
        os.environ[ENVIRONMENT_LOG_LEVEL_KEY])) + ") Increase log level to \"debug\" or \"trace\" to dump all container environment variables.")

    log_format = "CONSOLE"
    log_format_message = " Run container with command argument --logjson to switch to JSON log format."
    if log_json:
        log_format = "JSON"
        log_format_message = ""

    os.environ[ENVIRONMENT_LOG_FORMAT_KEY] = log_format
    info(ENVIRONMENT_LOG_FORMAT_KEY + "=" +
         os.environ[ENVIRONMENT_LOG_FORMAT_KEY] + log_format_message)


def get_container_image():
    return os.environ.get(ENVIRONMENT_IMAGE_NAME_KEY, '') + ':' + os.environ.get(ENVIRONMENT_IMAGE_TAG_KEY, '')


def is_multiprocess_container():
    return len(listdir(RUN_PROCESS_DIR)) > 1


def is_single_process_container():
    return len(listdir(RUN_PROCESS_DIR)) == 1


def get_container_process():
    for p in listdir(RUN_PROCESS_DIR):
        return os.path.join(RUN_PROCESS_DIR, p, 'run')


def is_runit_installed():
    return os.path.exists('/usr/bin/sv')


# Waits for the child process with the given PID, while at the same time
# reaping any other child processes that have exited (e.g. adopted child
# processes that have terminated).
def waitpid_reap_other_children(pid):
    global terminated_child_processes

    status = terminated_child_processes.get(pid)
    if status:
        # A previous call to waitpid_reap_other_children(),
        # with an argument not equal to the current argument,
        # already waited for this process. Return the status
        # that was obtained back then.
        del terminated_child_processes[pid]
        return status

    done = False
    status = None
    while not done:
        try:
            # https://github.com/phusion/baseimage-docker/issues/151#issuecomment-92660569
            this_pid, status = os.waitpid(pid, os.WNOHANG)
            if this_pid == 0:
                this_pid, status = os.waitpid(-1, 0)
            if this_pid == pid:
                done = True
            else:
                # Save status for later.
                terminated_child_processes[this_pid] = status
        except OSError as e:
            if e.errno == errno.ECHILD or e.errno == errno.ESRCH:
                return None
            else:
                raise
    return status


def stop_child_process(name, pid, signo=signal.SIGTERM, time_limit=KILL_PROCESS_TIMEOUT):
    info("Shutting down %s (PID %d)..." % (name, pid))
    try:
        os.kill(pid, signo)
    except OSError:
        pass
    signal.alarm(time_limit)
    try:
        try:
            waitpid_reap_other_children(pid)
        except OSError:
            pass
    except AlarmException:
        warning(
            "%s (PID %d) did not shut down in time. Forcing it to exit." % (name, pid))
        try:
            os.kill(pid, signal.SIGKILL)
        except OSError:
            pass
        try:
            waitpid_reap_other_children(pid)
        except OSError:
            pass
    finally:
        signal.alarm(0)


def run_command_killable(command):
    status = None
    pid = os.spawnvp(os.P_NOWAIT, command[0], command)
    try:
        status = waitpid_reap_other_children(pid)
    except BaseException:
        warning("An error occurred. Aborting.")
        stop_child_process(command[0], pid)
        raise
    if status != 0:
        if status is None:
            error("%s exited with unknown status\n" % command[0])
        else:
            error("%s failed with status %d\n" %
                  (command[0], os.WEXITSTATUS(status)))
        sys.exit(1)


def kill_all_processes(time_limit):
    info("Killing all processes...")
    try:
        os.kill(-1, signal.SIGTERM)
    except OSError:
        pass
    signal.alarm(time_limit)
    try:
        # Wait until no more child processes exist.
        done = False
        while not done:
            try:
                os.waitpid(-1, 0)
            except OSError as e:
                if e.errno == errno.ECHILD:
                    done = True
                else:
                    raise
    except AlarmException:
        warning("Not all processes have exited in time. Forcing them to exit.")
        try:
            os.kill(-1, signal.SIGKILL)
        except OSError:
            pass
    finally:
        signal.alarm(0)


def run_script_files(dir):
    for name in listdir(dir):
        filename = os.path.join(dir, name)
        if is_exe(filename):
            info("Running %s..." % filename)
            run_command_killable([filename])


def wait_for_process_or_interrupt(pid):
    status = waitpid_reap_other_children(pid)
    return (True, status)


def run_process(args, background_process_name, background_process_command):
    background_process_pid = run_background_process(
        background_process_name, background_process_command)
    background_process_exited = False
    exit_status = None

    if len(args.main_command) == 0:
        background_process_exited, exit_status = wait_background_process(
            background_process_name, background_process_pid)
    else:
        exit_status = run_foreground_process(args.main_command)

    return background_process_pid, background_process_exited, exit_status


def run_background_process(name, command):
    info("Running " + name + "...")
    pid = os.spawnvp(os.P_NOWAIT, command[0], command)
    debug("%s started as PID %d" % (name, pid))
    return pid


def wait_background_process(name, pid):
    exit_code = None
    exit_status = None
    process_exited = False

    process_exited, exit_code = wait_for_process_or_interrupt(pid)
    if process_exited:
        if exit_code is None:
            info(name + " exited with unknown status")
            exit_status = 1
        else:
            exit_status = os.WEXITSTATUS(exit_code)
            info("%s exited with status %d" % (name, exit_status))
    return (process_exited, exit_status)


def run_foreground_process(command):
    exit_code = None
    exit_status = None

    info("Running %s..." % " ".join(command))
    pid = os.spawnvp(os.P_NOWAIT, command[0], command)
    try:
        exit_code = waitpid_reap_other_children(pid)
        if exit_code is None:
            info("%s exited with unknown status." % command[0])
            exit_status = 1
        else:
            exit_status = os.WEXITSTATUS(exit_code)
            info("%s exited with status %d." % (command[0], exit_status))
    except KeyboardInterrupt:
        stop_child_process(command[0], pid)
        raise
    except BaseException:
        error("An error occurred. Aborting.")
        stop_child_process(command[0], pid)
        raise

    return exit_status


def shutdown_runit_services():
    debug("Begin shutting down runit services...")
    subprocess.run("/usr/bin/sv -w %d force-stop %s/* > /dev/null" %
                   (KILL_PROCESS_TIMEOUT, RUN_PROCESS_DIR), shell=True)


def wait_for_runit_services():
    debug("Waiting for runit services to exit...")
    done = False
    while not done:
        done = subprocess.run("/usr/bin/sv status " + RUN_PROCESS_DIR +
                              "/* | grep -q '^run:'", shell=True).returncode != 0
        if not done:
            time.sleep(0.1)
            shutdown_runit_services()


def run_multiprocess_container(args):
    if not is_runit_installed():
        error("Runit is not installed and this is a multiprocess container.")
        return

    background_process_exited = False
    background_process_pid = None

    try:
        runit_command = ["/usr/bin/runsvdir", "-P", RUN_PROCESS_DIR]
        background_process_pid, background_process_exited, exit_status = run_process(
            args, "runit daemon", runit_command)

        sys.exit(exit_status)
    finally:
        shutdown_runit_services()
        if not background_process_exited:
            stop_child_process("runit daemon", background_process_pid)
        wait_for_runit_services()


def run_single_process_container(args):
    background_process_exited = False
    background_process_pid = None

    try:
        container_process = get_container_process()
        background_process_pid, background_process_exited, exit_status = run_process(
            args, container_process, [container_process])

        sys.exit(exit_status)
    finally:
        if not background_process_exited:
            stop_child_process(container_process, background_process_pid)


def run_no_process_container(args):
    if len(args.main_command) == 0:
        args.main_command = ['bash']  # Run bash by default.

    exit_status = run_foreground_process(args.main_command)
    sys.exit(exit_status)


def run_cmds(cmds, when):
    if not cmds:
        return

    debug("Run commands before " + when + "...")
    for cmd in cmds:
        info("Running " + cmd + "...")
        run_command_killable(shlex.split(cmd))


def main(args):
    set_dir_env()
    set_log_env()

    if args.unsecure_fast_write:
        info("Unsecure fast write is enabled: setting LD_PRELOAD=libeatmydata.so")
        os.environ["LD_PRELOAD"] = "libeatmydata.so"

    try:
        debug(subprocess.run("/container/tools/install-services",
              shell=True, capture_output=True, text=True, check=True).stdout)
    except subprocess.CalledProcessError as e:
        warning(e.stdout)

    if not args.skip_env_files:
        import_env_files()

    if log_level >= LOG_LEVEL_DEBUG:
        debug_env()

    if not args.skip_startup:
        run_cmds(args.pre_startup_cmds, 'startup')
        run_script_files(RUN_STARTUP_DIR)

    if not args.skip_process:
        run_cmds(args.pre_process_cmds, 'process')

        if is_single_process_container():
            run_single_process_container(args)
        elif is_multiprocess_container():
            run_multiprocess_container(args)
        else:
            run_no_process_container(args)


# Command line options.
parser = argparse.ArgumentParser(prog='', description='Container image: ' + get_container_image(
), epilog='Built with osixia/light-baseimage (https://github.com/osixia/docker-light-baseimage) 🐳✨🌴')

parser.add_argument('main_command', metavar='MAIN_COMMAND', type=str, nargs='*',
                    help='the main command to run in addition of container processes (default value: /bin/bash if the container have no process, none otherwise)')
parser.add_argument('-v', '--version', dest='version',
                    action='store_true',
                    help='print container image version')

generator_group = parser.add_argument_group('templates generator')
generator_group.add_argument('--generate', type=str, choices=["dockerfile", "dagger.io"], dest='generate',
                             help='generate base templates for single process image')
generator_group.add_argument('--generate-multiprocess', type=str, choices=["dockerfile", "dagger.io"], dest='generate_multiprocess',
                             help='generate base templates for multiprocess image')
generator_group.add_argument('--generate-service', metavar='NAME', dest='generate_service', action='append',
                             help='generate NAME service templates')
generator_group.add_argument('--generate-service-available', metavar='NAME', dest='generate_service_available', action='append',
                             help='generate NAME service available templates')

environment_group = parser.add_argument_group('environment variables')
environment_group.add_argument('-e', '--skip-env-files', dest='skip_env_files',
                               action='store_true',
                               help='skip getting environment variables values from .env file(s)')

lifecycle_group = parser.add_argument_group('container lifecycle steps')
lifecycle_group.add_argument('-s', '--skip-startup', dest='skip_startup',
                             action='store_true',
                             help='skip running pre-startup-cmd and service(s) startup.sh script(s)')
lifecycle_group.add_argument('-p', '--skip-process', dest='skip_process',
                             action='store_true',
                             help='skip running pre-process-cmd and service(s) process.sh script(s)')
lifecycle_group.add_argument('-f', '--skip-finish', dest='skip_finish',
                             action='store_true',
                             help='skip running pre-finish-cmd and service(s) finish.sh script(s)')
lifecycle_group.add_argument('-o', '--run-only', type=str, choices=["startup", "process", "finish"], dest='run_only',
                             help='run only this file type and ignore others')

commands_group = parser.add_argument_group('commands lifecycle hooks')
commands_group.add_argument('--pre-startup-cmd', metavar='COMMAND', dest='pre_startup_cmds', action='append',
                            help='run COMMAND before startup file(s)')
commands_group.add_argument('--pre-process-cmd', metavar='COMMAND', dest='pre_process_cmds', action='append',
                            help='run COMMAND before process file(s)')
commands_group.add_argument('--pre-finish-cmd', metavar='COMMAND', dest='pre_finish_cmds', action='append',
                            help='run COMMAND before finish file(s)')
commands_group.add_argument('--pre-exit-cmd', metavar='COMMAND', dest='pre_exit_cmds', action='append',
                            help='run COMMAND before container exits')

ci_cd_group = parser.add_argument_group('ci/cd')
ci_cd_group.add_argument('-w', '--unsecure-fast-write', dest='unsecure_fast_write',
                         action='store_true',
                         help='disable fsync and friends with eatmydata LD_PRELOAD library')

debug_group = parser.add_argument_group('debugging')
debug_group.add_argument('-k', '--no-kill-all-on-exit', dest='kill_all_on_exit',
                         action='store_false',
                         help='don\'t kill all processes on the system upon exiting')
debug_group.add_argument('-a', '--keep-alive', dest='keep_alive',
                         action='store_true',
                         help='keep alive container after all processes have exited')

logs_group = parser.add_argument_group('logging')
logs_group.add_argument('-j', '--logjson', dest='log_json',
                        action='store_true',
                        help='set log format to JSON.')
logs_group.add_argument('-l', '--loglevel', type=str, choices=log_level_switcher.keys(), dest='log_level', default=log_level_switcher_inv.get(log_level),
                        help='set log level, default: %s' % log_level_switcher_inv.get(log_level))

args = parser.parse_args()

# Print version and exists.
if args.version:
    print(get_container_image())
    sys.exit(0)

# Set logs level and output type.
log_level = log_level_switcher.get(args.log_level)
log_json = args.log_json

# Generator options.
# Must be called before set_dir_env and set_log_env,
# so container environment variables are not replaced by envsubst-templates
generator(args)

# Validate and set run-only options.
if args.run_only is not None:
    if args.run_only == "startup" and args.skip_startup:
        error("When '--run-only startup' is set --skip-startup can't be set.")
        sys.exit(1)

    elif args.run_only == "process" and args.skip_startup:
        error("When '--run-only process' is set --skip-process can't be set.")
        sys.exit(1)

    elif args.run_only == "finish" and args.skip_startup:
        error("When '--run-only finish' is set --skip-finish can't be set.")
        sys.exit(1)

    if args.run_only == "startup":
        args.skip_process = True
        args.skip_finish = True
    elif args.run_only == "process":
        args.skip_startup = True
        args.skip_finish = True
    elif args.run_only == "finish":
        args.skip_startup = True
        args.skip_process = True

# Run main function.
signal.signal(signal.SIGTERM, lambda signum,
              frame: ignore_signals_and_raise_keyboard_interrupt('SIGTERM'))
signal.signal(signal.SIGINT, lambda signum,
              frame: ignore_signals_and_raise_keyboard_interrupt('SIGINT'))
signal.signal(signal.SIGALRM, lambda signum, frame: raise_alarm_exception())

exit_code = 0

try:
    main(args)

except SystemExit as e:
    exit_code = e.code

except KeyboardInterrupt:
    warning("Init system aborted.")
    exit(2)

finally:
    if not args.skip_finish:
        run_cmds(args.pre_finish_cmds, 'finish')
        run_script_files(RUN_FINISH_DIR)

    if args.kill_all_on_exit:
        kill_all_processes(KILL_ALL_PROCESSES_TIMEOUT)

    run_cmds(args.pre_exit_cmds, 'exit')

    if args.keep_alive:
        try:
            info("All process have exited, keep container alive...")
            while True:
                time.sleep(60)
                pass
        except:
            error("Keep alive process ended :o")

    exit(exit_code)
