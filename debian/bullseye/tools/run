#!/usr/bin/python3 -u
# -*- coding: utf-8 -*-

import os
import os.path
import subprocess
import sys
import stat
import signal
import errno
import argparse
import time
import shlex
import json
from datetime import datetime
from dotenv import load_dotenv

KILL_PROCESS_TIMEOUT = int(os.environ.get('CONTAINER_KILL_PROCESS_TIMEOUT', 30))
KILL_ALL_PROCESSES_TIMEOUT = int(os.environ.get('CONTAINER_KILL_ALL_PROCESSES_TIMEOUT', 30))

LOG_LEVEL_NONE = 0
LOG_LEVEL_ERROR = 1
LOG_LEVEL_WARNING = 2
LOG_LEVEL_INFO = 3
LOG_LEVEL_DEBUG = 4
LOG_LEVEL_TRACE = 5

log_level = None
log_json = False
terminated_child_processes = {}

ENVIRONMENT_FILES_IMPORT_DIR = "/container/environment"
ENVIRONMENT_FILES_PREFIX = ('.env')

# keep sync with values in install-services file
RUN_DIR = "/container/run"
RUN_STARTUP_DIR = RUN_DIR + "/startup"
RUN_PROCESS_DIR = RUN_DIR + "/process"
RUN_FINISH_DIR = RUN_DIR + "/finish"

RUN_VAR_DIR = "/container/run/var"
RUN_VAR_STATE_DIR = RUN_VAR_DIR + "/state"

ENVIRONMENT_LOG_LEVEL_KEY = 'CONTAINER_LOG_LEVEL'
ENVIRONMENT_LOG_FORMAT_KEY = 'CONTAINER_LOG_FORMAT'
ENVIRONMENT_VAR_DIR_KEY = 'CONTAINER_VAR_DIR'
ENVIRONMENT_STATE_DIR_KEY = 'CONTAINER_STATE_DIR'

ENVIRONMENT_IMAGE_NAME_KEY = 'CONTAINER_IMAGE_NAME'
ENVIRONMENT_IMAGE_TAG_KEY = 'CONTAINER_IMAGE_TAG'


class AlarmException(Exception):
    pass


def write_log(level, message):
    now = datetime.now().isoformat()

    if log_json:
        dictionary = {"datetime": now, "level": level.strip(), "message": message}
        sys.stderr.write(json.dumps(dictionary) + "\n")
        return

    for line in message.splitlines():
        sys.stderr.write("*** %s | %s | %s\n" % (now, level, line))


def error(message):
    if log_level >= LOG_LEVEL_ERROR:
        write_log(" ERROR ", message)


def warning(message):
    if log_level >= LOG_LEVEL_WARNING:
        write_log("WARNING", message)


def info(message):
    if log_level >= LOG_LEVEL_INFO:
        write_log(" INFO  ", message)


def debug(message):
    if log_level >= LOG_LEVEL_DEBUG:
        write_log(" DEBUG ", message)


def trace(message):
    if log_level >= LOG_LEVEL_TRACE:
        write_log(" TRACE ", message)


def debug_env():
    message = "Environment variables :\n"
    for name, value in list(os.environ.items()):
        message += name + "=" + value + "\n"
    debug(message)


def ignore_signals_and_raise_keyboard_interrupt(signame):
    signal.signal(signal.SIGTERM, signal.SIG_IGN)
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    raise KeyboardInterrupt(signame)


def raise_alarm_exception():
    raise AlarmException('Alarm')


def listdir(path):
    try:
        result = os.stat(path)
    except OSError:
        return []
    if stat.S_ISDIR(result.st_mode):
        return sorted(os.listdir(path))
    else:
        return []


def is_exe(path):
    try:
        return os.path.isfile(path) and os.access(path, os.X_OK)
    except OSError:
        return False


def xstr(s):
    if s is None:
        return ''
    return str(s)


def import_env_files():
    if not os.path.exists(ENVIRONMENT_FILES_IMPORT_DIR):
        warning(ENVIRONMENT_FILES_IMPORT_DIR + " don't exists")
        return

    env_backup = dict(os.environ)

    for subdir, _, files in os.walk(ENVIRONMENT_FILES_IMPORT_DIR):
        for file in sorted(files):
            if file.startswith(ENVIRONMENT_FILES_PREFIX):

                filepath = os.path.join(subdir, file)

                info('Load environment file ' + filepath)
                load_dotenv(filepath, override=True)
                set_env(env_backup)


def set_env(env):
    for k, v in env.items():
            if v is not None:
                os.environ[k] = v


def set_dir_env():
    os.environ[ENVIRONMENT_VAR_DIR_KEY] = RUN_VAR_DIR
    trace(ENVIRONMENT_VAR_DIR_KEY + "=" + os.environ[ENVIRONMENT_VAR_DIR_KEY])

    os.environ[ENVIRONMENT_STATE_DIR_KEY] = RUN_VAR_STATE_DIR
    trace(ENVIRONMENT_STATE_DIR_KEY + "=" + os.environ[ENVIRONMENT_STATE_DIR_KEY])


def set_log_env():
    os.environ[ENVIRONMENT_LOG_LEVEL_KEY] = xstr(log_level)
    info(ENVIRONMENT_LOG_LEVEL_KEY + "=" + os.environ[ENVIRONMENT_LOG_LEVEL_KEY] + " (" + log_level_switcher_inv.get(int(os.environ[ENVIRONMENT_LOG_LEVEL_KEY])) + ") Increase log level to \"debug\" or \"trace\" to dump all container environment variables.")

    log_format = "CONSOLE"
    log_format_message = " Run container with command argument --logjson to switch to JSON log format."
    if log_json:
        log_format = "JSON"
        log_format_message = ""

    os.environ[ENVIRONMENT_LOG_FORMAT_KEY] = log_format
    info(ENVIRONMENT_LOG_FORMAT_KEY + "=" + os.environ[ENVIRONMENT_LOG_FORMAT_KEY] + log_format_message)


def is_multiple_process_container():
    return len(listdir(RUN_PROCESS_DIR)) > 1


def is_single_process_container():
    return len(listdir(RUN_PROCESS_DIR)) == 1


def is_no_process_container():
    return not is_single_process_container() and not is_multiple_process_container()


def get_container_process():
    for p in listdir(RUN_PROCESS_DIR):
        return os.path.join(RUN_PROCESS_DIR, p, 'run')


def is_runit_installed():
    return os.path.exists('/usr/bin/sv')


# Waits for the child process with the given PID, while at the same time
# reaping any other child processes that have exited (e.g. adopted child
# processes that have terminated).
def waitpid_reap_other_children(pid):
    global terminated_child_processes

    status = terminated_child_processes.get(pid)
    if status:
        # A previous call to waitpid_reap_other_children(),
        # with an argument not equal to the current argument,
        # already waited for this process. Return the status
        # that was obtained back then.
        del terminated_child_processes[pid]
        return status

    done = False
    status = None
    while not done:
        try:
            # https://github.com/phusion/baseimage-docker/issues/151#issuecomment-92660569
            this_pid, status = os.waitpid(pid, os.WNOHANG)
            if this_pid == 0:
                this_pid, status = os.waitpid(-1, 0)
            if this_pid == pid:
                done = True
            else:
                # Save status for later.
                terminated_child_processes[this_pid] = status
        except OSError as e:
            if e.errno == errno.ECHILD or e.errno == errno.ESRCH:
                return None
            else:
                raise
    return status


def stop_child_process(name, pid, signo=signal.SIGTERM, time_limit=KILL_PROCESS_TIMEOUT):
    info("Shutting down %s (PID %d)..." % (name, pid))
    try:
        os.kill(pid, signo)
    except OSError:
        pass
    signal.alarm(time_limit)
    try:
        try:
            waitpid_reap_other_children(pid)
        except OSError:
            pass
    except AlarmException:
        warning("%s (PID %d) did not shut down in time. Forcing it to exit." % (name, pid))
        try:
            os.kill(pid, signal.SIGKILL)
        except OSError:
            pass
        try:
            waitpid_reap_other_children(pid)
        except OSError:
            pass
    finally:
        signal.alarm(0)


def run_command_killable(command):
    status = None
    pid = os.spawnvp(os.P_NOWAIT, command[0], command)
    try:
        status = waitpid_reap_other_children(pid)
    except BaseException:
        warning("An error occurred. Aborting.")
        stop_child_process(command[0], pid)
        raise
    if status != 0:
        if status is None:
            error("%s exited with unknown status\n" % command[0])
        else:
            error("%s failed with status %d\n" % (command[0], os.WEXITSTATUS(status)))
        sys.exit(1)


def kill_all_processes(time_limit):
    info("Killing all processes...")
    try:
        os.kill(-1, signal.SIGTERM)
    except OSError:
        pass
    signal.alarm(time_limit)
    try:
        # Wait until no more child processes exist.
        done = False
        while not done:
            try:
                os.waitpid(-1, 0)
            except OSError as e:
                if e.errno == errno.ECHILD:
                    done = True
                else:
                    raise
    except AlarmException:
        warning("Not all processes have exited in time. Forcing them to exit.")
        try:
            os.kill(-1, signal.SIGKILL)
        except OSError:
            pass
    finally:
        signal.alarm(0)


def run_script_files(dir):
    for name in listdir(dir):
        filename = os.path.join(dir, name)
        if is_exe(filename):
            info("Running %s..." % filename)
            run_command_killable([filename])


def wait_for_process_or_interrupt(pid):
    status = waitpid_reap_other_children(pid)
    return (True, status)


def run_process(args, background_process_name, background_process_command):
    background_process_pid = run_background_process(background_process_name, background_process_command)
    background_process_exited = False
    exit_status = None

    if len(args.main_command) == 0:
        background_process_exited, exit_status = wait_background_process(background_process_name, background_process_pid)
    else:
        exit_status = run_foreground_process(args.main_command)

    return background_process_pid, background_process_exited, exit_status


def run_background_process(name, command):
    info("Running " + name + "...")
    pid = os.spawnvp(os.P_NOWAIT, command[0], command)
    debug("%s started as PID %d" % (name, pid))
    return pid


def wait_background_process(name, pid):
    exit_code = None
    exit_status = None
    process_exited = False

    process_exited, exit_code = wait_for_process_or_interrupt(pid)
    if process_exited:
        if exit_code is None:
            info(name + " exited with unknown status")
            exit_status = 1
        else:
            exit_status = os.WEXITSTATUS(exit_code)
            info("%s exited with status %d" % (name, exit_status))
    return (process_exited, exit_status)


def run_foreground_process(command):
    exit_code = None
    exit_status = None

    info("Running %s..." % " ".join(command))
    pid = os.spawnvp(os.P_NOWAIT, command[0], command)
    try:
        exit_code = waitpid_reap_other_children(pid)
        if exit_code is None:
            info("%s exited with unknown status." % command[0])
            exit_status = 1
        else:
            exit_status = os.WEXITSTATUS(exit_code)
            info("%s exited with status %d." % (command[0], exit_status))
    except KeyboardInterrupt:
        stop_child_process(command[0], pid)
        raise
    except BaseException:
        error("An error occurred. Aborting.")
        stop_child_process(command[0], pid)
        raise

    return exit_status


def shutdown_runit_services():
    debug("Begin shutting down runit services...")
    subprocess.run("/usr/bin/sv -w %d force-stop %s/* > /dev/null" % (KILL_PROCESS_TIMEOUT, RUN_PROCESS_DIR), shell=True)


def wait_for_runit_services():
    debug("Waiting for runit services to exit...")
    done = False
    while not done:
        done = subprocess.run("/usr/bin/sv status " + RUN_PROCESS_DIR + "/* | grep -q '^run:'", shell=True).returncode != 0
        if not done:
            time.sleep(0.1)
            shutdown_runit_services()


def run_multiple_process_container(args):
    if not is_runit_installed():
        error("Error: runit is not installed and this is a multiple process container.")
        return

    background_process_exited = False
    background_process_pid = None

    try:
        runit_command = ["/usr/bin/runsvdir", "-P", RUN_PROCESS_DIR]
        background_process_pid, background_process_exited, exit_status = run_process(args, "runit daemon", runit_command)

        sys.exit(exit_status)
    finally:
        shutdown_runit_services()
        if not background_process_exited:
            stop_child_process("runit daemon", background_process_pid)
        wait_for_runit_services()


def run_single_process_container(args):
    background_process_exited = False
    background_process_pid = None

    try:
        container_process = get_container_process()
        background_process_pid, background_process_exited, exit_status = run_process(args, container_process, [container_process])

        sys.exit(exit_status)
    finally:
        if not background_process_exited:
            stop_child_process(container_process, background_process_pid)


def run_no_process_container(args):
    if len(args.main_command) == 0:
        args.main_command = ['bash']  # run bash by default

    exit_status = run_foreground_process(args.main_command)
    sys.exit(exit_status)


def run_cmds(cmds, when):
    if not cmds:
        return

    debug("Run commands before " + when + "...")
    for cmd in cmds:
            info("Running " + cmd[0] + "...")
            run_command_killable(shlex.split(cmd[0]))


def main(args):
    set_dir_env()
    set_log_env()

    if args.unsecure_fast_write:
        info("Unsecure fast write is enabled : setting LD_PRELOAD=libeatmydata.so")
        os.environ["LD_PRELOAD"] = "libeatmydata.so"

    try:
        debug(subprocess.run("/container/tools/install-services", shell=True, capture_output=True, text=True, check=True).stdout)
    except subprocess.CalledProcessError as e:
        warning(e.stdout)

    if not args.skip_env_files:
        import_env_files()

    if log_level >= LOG_LEVEL_DEBUG:
        debug_env()

    if not args.skip_startup:
        run_cmds(args.pre_startup_cmds, 'startup')
        run_script_files(RUN_STARTUP_DIR)

    if is_no_process_container() or args.skip_process:
        run_no_process_container(args)

    else:
        run_cmds(args.pre_process_cmds, 'process')

        if is_single_process_container():
            run_single_process_container(args)

        elif is_multiple_process_container():
            run_multiple_process_container(args)


# Parse options.
parser = argparse.ArgumentParser(prog='', description='Container image: ' + os.environ.get(ENVIRONMENT_IMAGE_NAME_KEY, '') + ':' + os.environ.get(ENVIRONMENT_IMAGE_TAG_KEY, ''), epilog='Built with osixia/light-baseimage (https://github.com/osixia/docker-light-baseimage) 🐳✨🌴')
parser.add_argument('main_command', metavar='MAIN_COMMAND', type=str, nargs='*',
                    help='The main command to run, leave empty to only run container process. Otherwise this command is run before startup scripts')

generators_group = parser.add_argument_group('template generators')
generators_group.add_argument('--generate', type=str, choices=["dockerfile", "dagger.io"], dest='generate', default=None,
                              help='Generate base templates for single process image')
generators_group.add_argument('--generate-multiprocess', type=str, choices=["dockerfile", "dagger.io"], dest='generate_multiprocess', default=None,
                              help='Generate base templates for multiprocess image')
generators_group.add_argument('--generate-service', metavar='NAME', dest='pre_exit_cmds', type=str,
                              action='append', default=[], nargs=1,
                              help='Generate NAME service templates')
generators_group.add_argument('--generate-service-available', metavar='NAME', dest='pre_exit_cmds', type=str,
                              action='append', default=[], nargs=1,
                              help='Generate NAME service available templates')

environment_group = parser.add_argument_group('environment variables')
environment_group.add_argument('-e', '--skip-env-files', dest='skip_env_files',
                               action='store_true',
                               help='Skip getting environment variables values from .env file(s)')

lifecycle_group = parser.add_argument_group('container lifecycle steps')
lifecycle_group.add_argument('-s', '--skip-startup', dest='skip_startup',
                             action='store_true',
                             help='Skip running pre-startup-cmd and service(s) startup.sh script(s)')
lifecycle_group.add_argument('-p', '--skip-process', dest='skip_process',
                             action='store_true',
                             help='Skip running pre-process-cmd and service(s) process.sh script(s)')
lifecycle_group.add_argument('-f', '--skip-finish', dest='skip_finish',
                             action='store_true',
                             help='Skip running pre-finish-cmd and service(s) finish.sh script(s)')
lifecycle_group.add_argument('-o', '--run-only', type=str, choices=["startup", "process", "finish"], dest='run_only', default=None,
                             help='Run only this file type and ignore others')

commands_group = parser.add_argument_group('commands lifecycle hooks')
commands_group.add_argument('--pre-startup-cmd', metavar='COMMAND', dest='pre_startup_cmds', type=str,
                            action='append', default=[], nargs=1,
                            help='Run COMMAND before startup file(s)')
commands_group.add_argument('--pre-process-cmd', metavar='COMMAND', dest='pre_process_cmds', type=str,
                            action='append', default=[], nargs=1,
                            help='Run COMMAND before process file(s)')
commands_group.add_argument('--pre-finish-cmd', metavar='COMMAND', dest='pre_finish_cmds', type=str,
                            action='append', default=[], nargs=1,
                            help='Run COMMAND before finish file(s)')
commands_group.add_argument('--pre-exit-cmd', metavar='COMMAND', dest='pre_exit_cmds', type=str,
                            action='append', default=[], nargs=1,
                            help='Run COMMAND before container exits')

ci_cd_group = parser.add_argument_group('ci/cd')
ci_cd_group.add_argument('-w', '--unsecure-fast-write', dest='unsecure_fast_write',
                         action='store_true',
                         help='Disable fsync and friends with eatmydata LD_PRELOAD library. Can help to speed up CI/CD pipelines. Use with caution')

debug_group = parser.add_argument_group('debugging')
debug_group.add_argument('-k', '--no-kill-all-on-exit', dest='kill_all_on_exit',
                         action='store_false',
                         help='Don\'t kill all processes on the system upon exiting')
debug_group.add_argument('-a', '--keepalive', dest='keepalive',
                         action='store_true',
                         help='Keep alive container after all process have exited')
debug_group.add_argument('-v', '--version', dest='version',
                         action='store_true',
                         help='Print container image version')

logs_group = parser.add_argument_group('logging')
logs_group.add_argument('-j', '--logjson', dest='log_json',
                        action='store_true',
                        help='Set log format to JSON.')
logs_group.add_argument('-l', '--loglevel', type=str, choices=["none", "error", "warning", "info", "debug", "trace"], dest='log_level', default="info",
                        help='Set log level, default: info')

args = parser.parse_args()

log_level_switcher = {"none": LOG_LEVEL_NONE, "error": LOG_LEVEL_ERROR, "warning": LOG_LEVEL_WARNING, "info": LOG_LEVEL_INFO, "debug": LOG_LEVEL_DEBUG, "trace": LOG_LEVEL_TRACE}
log_level_switcher_inv = {LOG_LEVEL_NONE: "none", LOG_LEVEL_ERROR: "error", LOG_LEVEL_WARNING: "warning", LOG_LEVEL_INFO: "info", LOG_LEVEL_DEBUG: "debug", LOG_LEVEL_TRACE: "trace"}
log_level = log_level_switcher.get(args.log_level)
log_json = args.log_json

# Run only arg
if args.run_only is not None:
    if args.run_only == "startup" and args.skip_startup:
        error("Error: When '--run-only startup' is set '--skip-startup' can't be set.")
        sys.exit(1)
    elif args.run_only == "process" and args.skip_startup:
        error("Error: When '--run-only process' is set '--skip-process' can't be set.")
        sys.exit(1)
    elif args.run_only == "finish" and args.skip_startup:
        error("Error: When '--run-only finish' is set '--skip-finish' can't be set.")
        sys.exit(1)

    if args.run_only == "startup":
        args.skip_process = True
        args.skip_finish = True
    elif args.run_only == "process":
        args.skip_startup = True
        args.skip_finish = True
    elif args.run_only == "finish":
        args.skip_startup = True
        args.skip_process = True

# single and multiple process image with main command
if len(args.main_command) != 0 and (is_single_process_container() or is_multiple_process_container()):
    args.pre_startup_cmds.append([' '.join(shlex.quote(x) for x in args.main_command)])
    args.main_command = []

# Run main function.
signal.signal(signal.SIGTERM, lambda signum, frame: ignore_signals_and_raise_keyboard_interrupt('SIGTERM'))
signal.signal(signal.SIGINT, lambda signum, frame: ignore_signals_and_raise_keyboard_interrupt('SIGINT'))
signal.signal(signal.SIGALRM, lambda signum, frame: raise_alarm_exception())

exit_code = 0

try:
    main(args)

except SystemExit as e:
    exit_code = e.code

except KeyboardInterrupt:
    warning("Init system aborted.")
    exit(2)

finally:
    if not args.skip_finish:
        run_cmds(args.pre_finish_cmds, 'finish')
        run_script_files(RUN_FINISH_DIR)

    if args.kill_all_on_exit:
        kill_all_processes(KILL_ALL_PROCESSES_TIMEOUT)

    run_cmds(args.pre_exit_cmds, 'exit')

    if args.keepalive:
        try:
            info("All process have exited, keep container alive...")
            while True:
                time.sleep(60)
                pass
        except:
            error("Keep alive process ended :o")

    exit(exit_code)
