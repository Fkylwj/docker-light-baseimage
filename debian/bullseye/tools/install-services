#!/usr/bin/python3 -u

# Usage:
# install-services

import os
import os.path
import stat
import subprocess

SERVICE_DIR = "/container/services"

INSTALL_FILENAME = "install.sh"
STARTUP_FILENAME = "startup.sh"
PROCESS_FILENAME = "process.sh"
FINISH_FILENAME = "finish.sh"

# Keep sync with values in entrypoint file.
ENTRYPOINT_DIR = "/container/entrypoint"
ENTRYPOINT_STARTUP_DIR = ENTRYPOINT_DIR + "/startup"
ENTRYPOINT_PROCESS_DIR = ENTRYPOINT_DIR + "/process"
ENTRYPOINT_FINISH_DIR = ENTRYPOINT_DIR + "/finish"


def chmod_x(script):
    try:
        st = os.stat(script)
        os.chmod(script, st.st_mode | stat.S_IEXEC)
    except Exception as e:
        print("Error: chmod +x failed on %s" % script)
        exit(1)


def install(script):
    if not os.path.isfile(script):
        return

    if not os.access(script, os.X_OK):
        chmod_x(script)

    print("Running %s..." % script)
    subprocess.run(script, shell=True)

    print("Remove %s" % script)
    os.remove(script)


def link(script, dest):
    if not os.path.isfile(script):
        return

    if not os.access(script, os.X_OK):
        chmod_x(script)

    if os.path.islink(dest) and os.readlink(dest) == script:
        return

    try:
        os.makedirs(os.path.dirname(dest), exist_ok=True)
        os.symlink(script, dest)
        print("Link %s to %s" % (script, dest))
    except OSError as e:
        print("Error: failed to link %s to %s: %s" % (script, dest, str(e)))
        print_write_error_helper_and_exit()


def print_write_error_helper_and_exit():
    print("If this error is displayed during container run this may be because the container filesystem is read only. Consider adding \"RUN /container/tools/install-services\" in the Dockerfile. Dynamically adding new service in readonly container is not supported.")
    print("If this error is displayed during image build, follow recommendations to fix the build process.")
    exit(1)


print("Running install-services...")

# Run /container/services/install.sh
install(os.path.join(SERVICE_DIR, INSTALL_FILENAME))

# Run install.sh scripts of /container/services/*
# Link startup.sh scripts of /container/services/* to /container/run/startup/*
# Link process.sh scripts of /container/services/* to /container/run/process/*/run
# Link finish.sh scripts of /container/services/* to /container/run/finish/*
for service in sorted(os.listdir(SERVICE_DIR)):
    service_directory = os.path.join(SERVICE_DIR, service)

    install(os.path.join(service_directory, INSTALL_FILENAME))

    scripts_to_link = {
        os.path.join(service_directory, STARTUP_FILENAME): os.path.join(ENTRYPOINT_STARTUP_DIR, service),
        os.path.join(service_directory, PROCESS_FILENAME): os.path.join(ENTRYPOINT_PROCESS_DIR, service, "run"),
        os.path.join(service_directory, FINISH_FILENAME): os.path.join(ENTRYPOINT_FINISH_DIR, service)
    }

    for script, dest in scripts_to_link.items():
        link(script, dest)


# Check all existing links in run directories
for ENTRYPOINT_DIR in (ENTRYPOINT_STARTUP_DIR, ENTRYPOINT_PROCESS_DIR, ENTRYPOINT_FINISH_DIR):
    for subdir, _, files in sorted(os.walk(ENTRYPOINT_DIR)):
        for file in files:
            filepath = os.path.join(subdir, file)

            if os.path.islink(file):
                real_path = os.readlink(file)

                if not os.path.exists(real_path):
                    try:
                        # Special case for process script that are in a subdirectory named after the service name in ENTRYPOINT_PROCESS_DIR
                        # we remove the subdirectory.
                        if(file.startswith(ENTRYPOINT_PROCESS_DIR)):
                            file = os.path.dirname(file)

                        print("Remove %s" % file)
                        os.remove(file)

                    except OSError as e:
                        print("Error: failed to remove %s: %s" %
                              (file, str(e)))
                        print_write_error_helper_and_exit()

                if not os.access(file, os.X_OK):
                    print("Error: file %s needs executable permission" % file)
                    exit(1)

nb_process = len(os.listdir(ENTRYPOINT_PROCESS_DIR))
print("%s process found." % nb_process)

# Multiprocess image.
if nb_process > 1:
    if not os.path.exists("/container/multiprocess_stack_added"):
        print("This image has multiple processes.")
        subprocess.run("/container/tools/packages-index-update", shell=True)
        subprocess.run(
            "/container/tools/add-multiprocess-stack", shell=True)
        subprocess.run("/container/tools/packages-index-clean", shell=True)
        subprocess.run("/container/tools/install-services", shell=True)
        print("For better image build process consider adding:")
        print("\"RUN packages-index-update && add-multiprocess-stack && packages-index-clean\" in the Dockerfile.")
